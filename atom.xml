<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-04T12:17:49.212Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VPS配置</title>
    <link href="http://yoursite.com/2020/09/04/%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/09/04/%E9%85%8D%E7%BD%AE/</id>
    <published>2020-09-04T05:45:11.000Z</published>
    <updated>2020-09-04T12:17:49.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容适用于 Ubuntu 系统；部分本地操作以在 macOS 下完成为例。</p><p>本文部分命令需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行。</p></blockquote><hr><h3 id="SSH-安全"><a href="#SSH-安全" class="headerlink" title="SSH 安全"></a>SSH 安全</h3><p>为了避免 VPS 被 ssh 弱口令扫描，用公私钥对进行 ssh 登录，并关闭密码登录。</p><p><strong>生成并添加密钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519  <span class="comment"># ED25519 算法，长度固定为 256 bits，安全性和性能最佳，兼容性稍差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ssh-keygen -t rsa -b 2048  <span class="comment"># RSA 算法，指定密钥长度为 2048 bits，兼容性最佳</span></span><br></pre></td></tr></table></figure><p>提示 <code>Enter file in which to save the key (/Users/~/.ssh/id_ed25519):</code><br><em># 使用默认文件位置，直接回车即可</em></p><p>提示 <code>Enter passphrase (empty for no passphrase):</code><br><em># 设置私钥的密码（留空即为免密码）</em></p><p>提示 <code>Enter same passphrase again:</code><br><em># 再次输入私钥的密码</em></p><p>此时就已经在 <code>~/.ssh/</code> 下生成了 <code>id_ed25519 (或 id_rsa)</code> (私钥) 和 <code>id_ed25519.pub (或 id_rsa.pub)</code> (公钥) 两个文件。</p><p><strong>在服务器端添加公钥</strong></p><p>使用 scp 命令将公钥上传到服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_ed25519.pub root@&lt;VPS域名或IP&gt;:/root/</span><br></pre></td></tr></table></figure><p>*# 输入 ssh 密码并回车确认</p><p>ssh 到服务器上，随后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.ssh &amp;&amp; chmod 700 ~/.ssh</span><br><span class="line"></span><br><span class="line">mv id_ed25519.pub ~/.ssh &amp;&amp; <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"></span><br><span class="line">mv id_ed25519.pub authorized_keys &amp;&amp; chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p>此时就可以使用密钥进行 ssh 登录了。</p><p><strong>macOS 本地配置</strong></p><p>如果不想每次使用密钥登录时都要输入密码，那么你可以编辑 ssh 配置文件将密码存储到钥匙串：</p><p>编辑 ssh 配置文件：<code>vim ~/.ssh/config</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes  # 用 ssh-agent 管理密钥</span><br><span class="line">  UseKeychain yes  # 将密码存储到钥匙串中</span><br><span class="line">  IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519  # 指定私钥路径</span><br></pre></td></tr></table></figure><p>如果你想通过代理 ssh 到你的服务器，那么再写入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;VPS域名或IP&gt;</span><br><span class="line">  ProxyCommand nc -X 5 -x 127.0.0.1:6153 %h %p</span><br><span class="line"></span><br><span class="line"># nc, netcat</span><br><span class="line"># -X 5, 指定使用 SOCKS5 代理</span><br><span class="line"># -x, 指定代理的主机地址和端口，示例中为本机的 6153 端口</span><br><span class="line"># %h %p, 用于替换 ssh 实际连接的主机地址和端口</span><br></pre></td></tr></table></figure><p><strong>关闭 ssh 的密码登录 &amp; 防止 Broken pipe 错误</strong></p><p>设置好密钥登录后，我们就可以关闭 ssh 的密码登录了。同时，为了避免在使用 ssh 时空闲连接时间过长而导致 <code>Write failed: Broken pipe</code> 错误，我们可以在 ssh 配置文件中设置 <code>ClientAliveInterval</code> 参数，这会允许服务器在一定时间内发送一个特定的包给客户端，一旦超时，则说明断线，就关闭连接，避免了空闲连接时间过长报错。</p><p>编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code>将<code>PasswordAuthentication yes</code> 改为 <code>PasswordAuthentication no</code>，并去除行前的注释符号 <code>#</code><br>将 <code>ClientAliveInterval</code> 一行改为 <code>ClientAliveInterval 60</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="创建普通用户并授予-sudo-权限"><a href="#创建普通用户并授予-sudo-权限" class="headerlink" title="创建普通用户并授予 sudo 权限"></a>创建普通用户并授予 sudo 权限</h3><p><strong>创建用户</strong></p><p>首先，使用 <code>useradd</code> 命令创建用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash &lt;username&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加用户名为 &lt;username&gt; 的用户</span></span><br><span class="line"><span class="comment"># -m, 自动创建用户家目录，并将 /etc/skel 中的文件复制到家目录中</span></span><br><span class="line"><span class="comment"># -s /bin/bash, 指定用户默认 shell 为 bash</span></span><br></pre></td></tr></table></figure><p>然后为该用户设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd &lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>授予用户 sudo 权限</strong></p><p>一般来说，Ubuntu 系统已经自带了 <code>sudo</code>；如果没有，则先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install sudo</span><br></pre></td></tr></table></figure><p>由于直接修改 <code>etc/sudoers</code> 文件有一定的危险性，因此我们采用将配置文件追加到 <code>/etc/sudoers.d/</code> 目录下的方式进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;username&gt; ALL=(ALL) ALL&#x27;</span> &gt;&gt; /etc/sudoers.d/&lt;username&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请自行将 &lt;username&gt; 改为你的用户名</span></span><br></pre></td></tr></table></figure><p><code>&lt;username&gt; ALL=(ALL) ALL</code> 表示普通用户 <code>&lt;username&gt;</code> 可以在任何主机上，通过 <code>sudo</code> 提权到任何用户/用户组，执行任何命令[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref04">4]</a>。</p><p>如果你想免密使用 <code>sudo</code><strong>（不安全）</strong>，那么上一步可以改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;username&gt; ALL=(ALL) NOPASSWD: ALL&#x27;</span> &gt;&gt; /etc/sudoers.d/&lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>解决部分机器 sudo 提示 unable to resolve host</strong></p><p>部分服务器在执行 <code>sudo</code> 时，会弹出以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">sudo: unable to resolve host &lt;hostname&gt;</span><br></pre></td></tr></table></figure><p>尽管不影响使用，但看着总让人不爽。这个错误是因为服务商提供的默认系统镜像没有将主机名 (hostname) 添加到 <code>/etc/hosts</code> 文件中，导致系统无法解析 hostname。使用以下命令即可解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1 <span class="subst">$(hostname)</span>&quot;</span> | sudo tee -a /etc/hosts</span><br></pre></td></tr></table></figure><p><strong>为用户启用 SSH</strong></p><p>首先切换到刚刚创建的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - &lt;username&gt;</span><br></pre></td></tr></table></figure><p>随后，建立 <code>~/.ssh</code> 目录，并将 <code>root</code> 用户下的 <code>authorized_keys</code> 复制过来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.ssh/</span><br><span class="line"></span><br><span class="line">sudo cp /root/.ssh/authorized_keys ~/.ssh/</span><br></pre></td></tr></table></figure><p>最后设置正确的访问权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R &lt;username&gt;:&lt;username&gt; ~/.ssh</span><br><span class="line">sudo chmod 700 ~/.ssh</span><br><span class="line">sudo chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>为了提高安全性，你还可以关闭 <code>root</code> 用户的 ssh 登录。编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code></p><p>将 <code>PermitRootLogin yes</code> 改为 <code>PermitRootLogin no</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p><strong>安装 fail2ban</strong></p><p>fail2ban 是 Linux 上一个著名的入侵保护的开源框架，它能通过 iptables 将尝试暴破 ssh 密码的 IP 封停，有效防止暴力破解攻击。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install fail2ban</span><br></pre></td></tr></table></figure><p><strong>安装并配置 UFW 防火墙</strong></p><p>ufw，即 uncomplicated firewall（简单防火墙），是 Ubuntu 系统默认的防火墙组件，它可以简化对 iptables 的配置。</p><ul><li><p>如果未安装 ufw，则先进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install ufw</span><br></pre></td></tr></table></figure></li></ul><p>#Ubuntu 系统已经自带了 ufw 防火墙</p><ul><li><p>添加基本的 ufw 规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ufw allow http  <span class="comment"># 允许 80 端口传入连接</span></span><br><span class="line"></span><br><span class="line">ufw allow https  <span class="comment"># 允许 443 端口传入连接</span></span><br><span class="line"></span><br><span class="line">ufw allow ssh  <span class="comment"># 允许 22 端口传入连接</span></span><br></pre></td></tr></table></figure></li><li><p>添加自定义端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 端口号</span><br><span class="line"></span><br><span class="line">ufw allow 10000:20000/tcp  <span class="comment"># 此处指定了 10000 到 20000 的端口范围，并指定只允许 TCP 连接</span></span><br></pre></td></tr></table></figure></li><li><p>开启 ufw</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li></ul><p>#会提示你可能影响 ssh 连接，务必确认已将你的 ssh 端口加入到 ufw rules 中，然后按 y 确认开启</p><ul><li><p>查看 ufw 状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw status</span><br></pre></td></tr></table></figure></li><li><p>删除某条规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw delete allow 端口号</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-NTP-同步系统时间"><a href="#使用-NTP-同步系统时间" class="headerlink" title="使用 NTP 同步系统时间"></a>使用 NTP 同步系统时间</h3><p>许多服务都要求服务器时间与标准时间误差不能过大，因此我们使用 NTP 进行时间同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install ntp</span><br></pre></td></tr></table></figure><p><strong>设置时区</strong></p><p>切换到与所在地相同的时区可以方便 crontab 等服务的设置。</p><p>查看可用时区列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></table></figure><p>设定时区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Hong_Kong  <span class="comment"># 将时区设置为 Asia/Hong_Kong</span></span><br></pre></td></tr></table></figure><p>查看当前时间设定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></table></figure><h3 id="配置无人值守更新（可选）"><a href="#配置无人值守更新（可选）" class="headerlink" title="配置无人值守更新（可选）"></a>配置无人值守更新（可选）</h3><p>一般来说，Ubuntu 系统已经自带了 <code>unattended-upgrades</code> 包；如果没有，则先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install unattended-upgrades</span><br></pre></td></tr></table></figure><p>随后，通过以下命令启用无人值守更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;unattended-upgrades unattended-upgrades/enable_auto_updates boolean true&quot;</span> | debconf-set-selections</span><br><span class="line"></span><br><span class="line">DEBIAN_FRONTEND=noninteractive dpkg-reconfigure unattended-upgrades</span><br></pre></td></tr></table></figure><p>通过编辑 <code>/etc/apt/apt.conf.d/</code> 下的 <code>20auto-upgrades</code> 和 <code>50unattended-upgrades</code> 两个配置文件，我们可以设定无人值守更新。</p><ul><li><p><code>/etc/apt/apt.conf.d/20auto-upgrades</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists &quot;1&quot;;</span><br><span class="line"># 自动更新软件包列表周期（天），0 为关闭</span><br><span class="line"></span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line"># 自动下载可更新的软件包周期（天），0 为关闭</span><br><span class="line"></span><br><span class="line">APT::Periodic::AutocleanInterval &quot;0&quot;;</span><br><span class="line"># 自动清理周期（天），0 为关闭</span><br><span class="line"></span><br><span class="line">APT::Periodic::Unattended-Upgrade &quot;1&quot;;</span><br><span class="line"># 自动更新软件包周期（天），0 为关闭</span><br></pre></td></tr></table></figure></li><li><p><code>/etc/apt/apt.conf.d/50unattended-upgrades</code></p></li></ul><p>以下为一些关键的设置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Unattended-Upgrade::Allowed-Origins &#123;</span><br><span class="line">... ...</span><br><span class="line">&#x2F;&#x2F;&quot;$&#123;distro_id&#125;:$&#123;distro_codename&#125;-updates&quot;;</span><br><span class="line">&#x2F;&#x2F; 自动更新（除安全更新外的）软件包，去除行前的注释符号 &#x2F;&#x2F; 以开启</span><br><span class="line">&#x2F;&#x2F; 注意：开启此选项有风险</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Kernel-Packages &quot;true&quot;;</span><br><span class="line">&#x2F;&#x2F; 自动移除无用内核，去除行前的注释符号 &#x2F;&#x2F; 以开启</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Dependencies &quot;false&quot;;</span><br><span class="line">&#x2F;&#x2F; 自动移除无用依赖，去除行前的注释符号 &#x2F;&#x2F; 并将 false 改为 true 以开启</span><br><span class="line">&#x2F;&#x2F; 等同于自动 apt-get autoremove</span><br></pre></td></tr></table></figure><p>本配置文件还提供了许多其他的设置项，并且有详细的注释，可自行查看编辑。</p><h3 id="启用-Canonical-Livepatch-服务（可选）"><a href="#启用-Canonical-Livepatch-服务（可选）" class="headerlink" title="启用 Canonical Livepatch 服务（可选）"></a>启用 Canonical Livepatch 服务（可选）</h3><p>在 Ubuntu 16.04 及以上的系统中，可以使用 Canonical Livepatch 服务实现无需重启系统就能安装内核安全补丁。同时，Canonical Livepatch 服务对于不超过 3 台机器的个人用户是免费的。</p><ol><li><p>在 <a href="https://auth.livepatch.canonical.com/">Canonical Livepatch Service 官网</a> 上选择 <code>Ubuntu user</code>，点击 <code>Get your Livepatch token</code></p></li><li><p>按要求注册（或登录）Ubuntu One 账号，获取 token</p></li><li><p>ssh 到服务器上，随后安装 Snapd 守护程序：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install snapd</span><br></pre></td></tr></table></figure><ol start="4"><li>安装 Canonical Livepatch 守护程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install canonical-livepatch</span><br></pre></td></tr></table></figure><ol start="5"><li>启用 Canonical Livepatch：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canonical-livepatch <span class="built_in">enable</span> &lt;token&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请自行将 &lt;token&gt; 换成第二步中获取的 token</span></span><br></pre></td></tr></table></figure><ol start="6"><li>查看 Canonical Livepatch 状态：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canonical-livepatch status</span><br></pre></td></tr></table></figure><ol start="7"><li>手动更新补丁：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canonical-livepatch refresh</span><br></pre></td></tr></table></figure><ol start="8"><li>停用 Canonical Livepatch：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap run canonical-livepatch <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：安装内核补丁与安装新内核不同，如果安装了新内核，则必须重新启动系统以应用新内核。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>提高文件并发数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;* soft nofile 51200</span></span><br><span class="line"><span class="string">* hard nofile 51200&#x27;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>然后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 51200</span><br></pre></td></tr></table></figure><p><strong>设置虚拟内存</strong></p><p>某些 VPS 服务商会预先设置好虚拟内存，所以我们先查看系统当前可用内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"></span><br><span class="line">Mem:            982         277         112           1         592         533</span><br><span class="line"></span><br><span class="line">Swap:          1023           2        1021</span><br></pre></td></tr></table></figure><p>如果输出中没有上面的 <code>Swap</code> 一行或 <code>Swap</code> 后为 0，则表示系统没有设置虚拟内存，可以参考下面的方法设置：</p><ol><li>创建 swapfile</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/root/swapfile bs=1M count=1024</span><br><span class="line"><span class="comment"># if 表示 input file (输入文件)，of 表示 output file (输出文件)，bs 表示 block size (块大小)，count 表示计数</span></span><br></pre></td></tr></table></figure><p>示例中采用的数据块大小为 1M，数据块计数为 1024，所以分配的空间就是 1G 大小。</p><ol start="2"><li>设置正确的 swapfile 权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /root/swapfile</span><br></pre></td></tr></table></figure><ol start="3"><li>格式化 swapfile</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /root/swapfile</span><br></pre></td></tr></table></figure><ol start="4"><li>启用 swapfile</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /root/swapfile</span><br></pre></td></tr></table></figure><ol start="5"><li>设置开机自动加载虚拟内存</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/root/swapfile swap swap defaults 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><p>此时再执行 <code>free -m</code> 即可看到虚拟内存已经启用了。</p><h3 id="开启-BBR-拥塞控制算法"><a href="#开启-BBR-拥塞控制算法" class="headerlink" title="开启 BBR 拥塞控制算法"></a>开启 BBR 拥塞控制算法</h3><p>BBR 是 Google 出品的 TCP 拥塞控制算法，其目的是尽量跑满带宽，可以起到单边加速 TCP 连接的效果。BBR 是内嵌在 Linux 内核中的，而 Linux kernel 4.9 已加入了该算法。如果你的系统内核版本低于 4.9，则需要先升级 Linux 内核。<br>*# Ubuntu 18.04 及以上系统内核版本已高于 4.9，可直接开启 BBR*</p><ol><li>开启 BBR</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>然后，执行 <code>sysctl -p</code> 保存生效。</p><ol start="2"><li>查看 BBR 是否成功开启</li></ol><p>执行 <code>sysctl net.ipv4.tcp_available_congestion_control</code>， 结果中应有 <code>bbr</code>。<br>执行 <code>lsmod | grep bbr</code>，结果中应有 <code>tcp_bbr</code>。</p><p><strong>自动升级内核</strong></p><p>默认情况下，Ubuntu LTS 将保持在最初发布的 Linux 内核上。而 Ubuntu 硬件支持栈（<strong>H</strong>ard<strong>w</strong>are <strong>E</strong>nablement Stacks, HWE）可以为现有的 Ubuntu LTS 提供更新的内核支持，实现内核自动升级，方便我们体验较新内核的特性[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref10">10]</a>。</p><ol><li>查看当前系统内核版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 HWE</li></ol><p>使用包管理器即可安装 HWE：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install --install-recommends linux-generic-hwe-20.04  <span class="comment"># For Ubuntu 20.04 LTS</span></span><br><span class="line"></span><br><span class="line">apt install --install-recommends linux-generic-hwe-18.04  <span class="comment"># For Ubuntu 18.04 LTS</span></span><br></pre></td></tr></table></figure><ol start="3"><li>重启系统以应用新内核</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><ol start="4"><li>删除旧内核（可选）[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref11">11]</a></li></ol><p>使用包管理器自动卸载即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt autoremove --purge</span><br></pre></td></tr></table></figure><p>如果只想保留当前最新的内核，可以使用以下命令<strong>（有风险，慎用）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt purge $(dpkg -l | grep -E <span class="string">&quot;linux-(image|headers|modules)&quot;</span> | grep -v hwe | grep -v $(uname -r | cut -d <span class="string">&#x27;-&#x27;</span> -f1,2) | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>或者也可以手动卸载：</p><p><strong>卸载旧版 linux-image：</strong></p><p>获取 linux-image 列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep linux-image</span><br></pre></td></tr></table></figure><p>卸载旧版 linux-image：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt purge &lt;旧linux-image名&gt;</span><br></pre></td></tr></table></figure><p><strong>卸载旧版 linux-headers：</strong></p><p>获取 linux-headers 列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep linux-headers</span><br></pre></td></tr></table></figure><p>卸载旧版 linux-headers：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt purge &lt;旧linux-headers名&gt;</span><br></pre></td></tr></table></figure><p><strong>卸载旧版 linux-modules：</strong></p><p>获取 linux-modules 列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep linux-modules</span><br></pre></td></tr></table></figure><p>卸载旧版 linux-modules：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt purge &lt;旧linux-modules名&gt;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>安装 Docker-CE</strong></p><p><a href="https://www.docker.com/">Docker</a> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。iOS 上的 <a href="https://www.hyperapp.fun/zh/">HyperApp</a> 也正是借助 Docker 实现了自动部署应用。</p><p>安装 Docker 最方便的方式是使用官方脚本[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref12">12]</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- get.docker.com | bash</span><br></pre></td></tr></table></figure><p>对于国内 VPS，还可以指定使用阿里云镜像进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p><strong>以普通用户管理 Docker</strong></p><p>由于 Docker 守护进程绑定在 Unix socket 上，而 Unix socket 默认仅属于 <code>root</code> 用户，因此在通过普通用户管理 Docker 时，我们需要在命令前加上 <code>sudo</code>。为了方便使用，我们可以将普通用户添加到 <code>docker</code> 用户组中，这样就能直接使用 <code>docker</code> 命令而不需要 <code>sudo</code>。</p><ol><li>创建 <code>docker</code> 用户组</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 较新的 Docker 安装中可能已经添加了 docker 用户组</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将当前用户加入 <code>docker</code> 组</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker</span><br></pre></td></tr></table></figure><ol start="3"><li>登出并重新登入当前用户</li></ol><p>或者，你也可以使用 <code>newgrp</code> 命令以 <code>docker</code> 组重新登入系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><p>此时就可以直接使用 <code>docker</code> 命令管理容器了。</p><p><strong>限制 Docker 容器日志大小</strong></p><p>Docker 容器运行过程中会产生大量日志文件，如果不加限制可能会导致 VPS 磁盘空间不足。通过编辑 Docker 配置文件，我们可以限制容器日志大小。</p><p>编辑 <code>/etc/docker/daemon.json</code> 文件：<code>vim /etc/docker/daemon.json</code></p><p>添加 <code>log-dirver</code>和 <code>log-opts</code> 参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;log-opts&quot;</span>: &#123; <span class="attr">&quot;max-size&quot;</span>: <span class="string">&quot;50m&quot;</span>, <span class="attr">&quot;max-file&quot;</span>: <span class="string">&quot;3&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#样例中一个容器的日志大小上限是 50 M，最多创建 3 个日志文件</p><p>对于国内 VPS，还可以在配置文件中配置国内镜像源：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;log-opts&quot;</span>: &#123; <span class="attr">&quot;max-size&quot;</span>: <span class="string">&quot;50m&quot;</span>, <span class="attr">&quot;max-file&quot;</span>: <span class="string">&quot;3&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://&lt;阿里云ID&gt;.mirror.aliyuncs.com&quot;</span>,<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#阿里云源地址可以在 <a href="https://cr.console.aliyun.com/">容器镜像服务</a> &gt; 镜像加速器 下查看</p><p>保存退出，随后加载配置文件并重启 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>#设置的日志大小，只对新建的容器有效</p><p><strong>手动清理 Docker 容器日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps | awk <span class="string">&#x27;&#123;if (NR&gt;1)&#123;print $1&#125;&#125;&#x27;</span> | xargs docker inspect --format=<span class="string">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> | xargs truncate -s 0</span><br></pre></td></tr></table></figure><p><strong>解决 UFW 对 Docker 容器无效的问题</strong></p><p>在使用 Docker 暴露容器端口时，Docker 会直接操作 iptables NAT 规则，导致 ufw 无法管理 Docker 所发布的端口，这是一个严重的安全问题。好在通过编辑 ufw 的 <code>after.rules</code>，我们能够解决这一问题。</p><p>编辑 ufw 的 <code>after.rules</code>：<code>vim /etc/ufw/after.rules</code></p><p>在末尾写入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># BEGIN UFW AND DOCKER</span><br><span class="line">*filter</span><br><span class="line">:ufw-user-forward - [0:0]</span><br><span class="line">:DOCKER-USER - [0:0]</span><br><span class="line">-A DOCKER-USER -j RETURN -s 10.0.0.0&#x2F;8</span><br><span class="line">-A DOCKER-USER -j RETURN -s 172.16.0.0&#x2F;12</span><br><span class="line">-A DOCKER-USER -j RETURN -s 192.168.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line">-A DOCKER-USER -j ufw-user-forward</span><br><span class="line"></span><br><span class="line">-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0&#x2F;16</span><br><span class="line">-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0&#x2F;8</span><br><span class="line">-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0&#x2F;12</span><br><span class="line">-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0&#x2F;16</span><br><span class="line">-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0&#x2F;8</span><br><span class="line">-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0&#x2F;12</span><br><span class="line"></span><br><span class="line">-A DOCKER-USER -j RETURN</span><br><span class="line">COMMIT</span><br><span class="line"># END UFW AND DOCKER</span><br></pre></td></tr></table></figure><p>保存退出，随后重启 ufw：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ufw</span><br></pre></td></tr></table></figure><p><em># 如果重启 ufw 之后规则没有生效，则需要重启服务器。</em></p><p>如果你要允许外部网络访问所有 Docker 发布的、内部端口为 <code>80</code> 的服务，则执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ufw route allow from any to any port 80</span><br><span class="line"></span><br><span class="line">ufw route allow proto tcp from any to any port 80  <span class="comment"># 仅允许 TCP 协议</span></span><br></pre></td></tr></table></figure><p><em># 此处的 <code>80</code> 是容器内部端口，而非使用 <code>-p 8080:80</code> 选项发布在服务器上的 <code>8080</code> 端口。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文内容适用于 Ubuntu 系统；部分本地操作以在 macOS 下完成为例。&lt;/p&gt;
&lt;p&gt;本文部分命令需要以 &lt;code&gt;root&lt;/code&gt; 用户或 &lt;code&gt;sudo&lt;/code&gt; 权限执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr</summary>
      
    
    
    
    
    <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
