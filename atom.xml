<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-05T14:24:16.426Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VPS配置</title>
    <link href="http://yoursite.com/2020/09/04/%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/09/04/%E9%85%8D%E7%BD%AE/</id>
    <published>2020-09-04T05:45:11.000Z</published>
    <updated>2020-09-05T14:24:16.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容适用于 Ubuntu 系统；部分本地操作以在 macOS 下完成为例。</p><p>本文部分命令需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行。</p></blockquote><hr><h3 id="SSH-安全"><a href="#SSH-安全" class="headerlink" title="SSH 安全"></a>SSH 安全</h3><p>为了避免 VPS 被 ssh 弱口令扫描，用公私钥对进行 ssh 登录，并关闭密码登录。</p><p><strong>生成并添加密钥</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t ed25519  <span class="token comment"># ED25519 算法，长度固定为 256 bits，安全性和性能最佳，兼容性稍差</span><span class="token comment"># 或者</span>ssh-keygen -t rsa -b <span class="token number">2048</span>  <span class="token comment"># RSA 算法，指定密钥长度为 2048 bits，兼容性最佳</span></code></pre><p>提示 <code>Enter file in which to save the key (/Users/~/.ssh/id_ed25519):</code><br><em># 使用默认文件位置，直接回车即可</em></p><p>提示 <code>Enter passphrase (empty for no passphrase):</code><br><em># 设置私钥的密码（留空即为免密码）</em></p><p>提示 <code>Enter same passphrase again:</code><br><em># 再次输入私钥的密码</em></p><p>此时就已经在 <code>~/.ssh/</code> 下生成了 <code>id_ed25519 (或 id_rsa)</code> (私钥) 和 <code>id_ed25519.pub (或 id_rsa.pub)</code> (公钥) 两个文件。</p><p><strong>在服务器端添加公钥</strong></p><p>使用 scp 命令将公钥上传到服务器：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> ~/.ssh/id_ed25519.pub root@<span class="token operator">&lt;</span>VPS域名或IP<span class="token operator">></span>:/root/</code></pre><p>*# 输入 ssh 密码并回车确认</p><p>ssh 到服务器上，随后执行</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">mv</span> id_ed25519.pub ~/.ssh <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> ~/.ssh<span class="token function">mv</span> id_ed25519.pub authorized_keys <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> <span class="token number">600</span> authorized_keys</code></pre><p>此时就可以使用密钥进行 ssh 登录了。</p><p><strong>macOS 本地配置</strong></p><p>如果不想每次使用密钥登录时都要输入密码，那么你可以编辑 ssh 配置文件将密码存储到钥匙串：</p><p>编辑 ssh 配置文件：<code>vim ~/.ssh/config</code></p><pre class="language-Plain" data-language="Plain"><code class="language-Plain">Host *  AddKeysToAgent yes  # 用 ssh-agent 管理密钥  UseKeychain yes  # 将密码存储到钥匙串中  IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519  # 指定私钥路径</code></pre><p>如果你想通过代理 ssh 到你的服务器，那么再写入如下内容：</p><pre class="language-Plain" data-language="Plain"><code class="language-Plain">Host &lt;VPS域名或IP&gt;  ProxyCommand nc -X 5 -x 127.0.0.1:6153 %h %p# nc, netcat# -X 5, 指定使用 SOCKS5 代理# -x, 指定代理的主机地址和端口，示例中为本机的 6153 端口# %h %p, 用于替换 ssh 实际连接的主机地址和端口</code></pre><p><strong>关闭 ssh 的密码登录 &amp; 防止 Broken pipe 错误</strong></p><p>设置好密钥登录后，我们就可以关闭 ssh 的密码登录了。同时，为了避免在使用 ssh 时空闲连接时间过长而导致 <code>Write failed: Broken pipe</code> 错误，我们可以在 ssh 配置文件中设置 <code>ClientAliveInterval</code> 参数，这会允许服务器在一定时间内发送一个特定的包给客户端，一旦超时，则说明断线，就关闭连接，避免了空闲连接时间过长报错。</p><p>编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code>将<code>PasswordAuthentication yes</code> 改为 <code>PasswordAuthentication no</code>，并去除行前的注释符号 <code>#</code><br>将 <code>ClientAliveInterval</code> 一行改为 <code>ClientAliveInterval 60</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="创建普通用户并授予-sudo-权限"><a href="#创建普通用户并授予-sudo-权限" class="headerlink" title="创建普通用户并授予 sudo 权限"></a>创建普通用户并授予 sudo 权限</h3><p><strong>创建用户</strong></p><p>首先，使用 <code>useradd</code> 命令创建用户：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> -m -s /bin/bash <span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token comment"># 添加用户名为 &lt;username> 的用户</span><span class="token comment"># -m, 自动创建用户家目录，并将 /etc/skel 中的文件复制到家目录中</span><span class="token comment"># -s /bin/bash, 指定用户默认 shell 为 bash</span></code></pre><p>然后为该用户设置密码：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span> <span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p><strong>授予用户 sudo 权限</strong></p><p>一般来说，Ubuntu 系统已经自带了 <code>sudo</code>；如果没有，则先安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">sudo</span></code></pre><p>由于直接修改 <code>etc/sudoers</code> 文件有一定的危险性，因此我们采用将配置文件追加到 <code>/etc/sudoers.d/</code> 目录下的方式进行配置。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'&lt;username> ALL=(ALL) ALL'</span> <span class="token operator">>></span> /etc/sudoers.d/<span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token comment"># 请自行将 &lt;username> 改为你的用户名</span></code></pre><p><code>&lt;username&gt; ALL=(ALL) ALL</code> 表示普通用户 <code>&lt;username&gt;</code> 可以在任何主机上，通过 <code>sudo</code> 提权到任何用户/用户组，执行任何命令[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref04">4]</a>。</p><p>如果你想免密使用 <code>sudo</code><strong>（不安全）</strong>，那么上一步可以改为：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'&lt;username> ALL=(ALL) NOPASSWD: ALL'</span> <span class="token operator">>></span> /etc/sudoers.d/<span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p><strong>解决部分机器 sudo 提示 unable to resolve host</strong></p><p>部分服务器在执行 <code>sudo</code> 时，会弹出以下错误：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token boolean">true</span>sudo: unable to resolve <span class="token function">host</span> <span class="token operator">&lt;</span>hostname<span class="token operator">></span></code></pre><p>尽管不影响使用，但看着总让人不爽。这个错误是因为服务商提供的默认系统镜像没有将主机名 (hostname) 添加到 <code>/etc/hosts</code> 文件中，导致系统无法解析 hostname。使用以下命令即可解决：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"127.0.0.1 <span class="token variable"><span class="token variable">$(</span><span class="token function">hostname</span><span class="token variable">)</span></span>"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> -a /etc/hosts</code></pre><p><strong>为用户启用 SSH</strong></p><p>首先切换到刚刚创建的用户：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">su</span> - <span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p>随后，建立 <code>~/.ssh</code> 目录，并将 <code>root</code> 用户下的 <code>authorized_keys</code> 复制过来：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/.ssh/<span class="token function">sudo</span> <span class="token function">cp</span> /root/.ssh/authorized_keys ~/.ssh/</code></pre><p>最后设置正确的访问权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> -R <span class="token operator">&lt;</span>username<span class="token operator">></span>:<span class="token operator">&lt;</span>username<span class="token operator">></span> ~/.ssh<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys</code></pre><p>为了提高安全性，你还可以关闭 <code>root</code> 用户的 ssh 登录。编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code></p><p>将 <code>PermitRootLogin yes</code> 改为 <code>PermitRootLogin no</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p><strong>安装 fail2ban</strong></p><p>fail2ban 是 Linux 上一个著名的入侵保护的开源框架，它能通过 iptables 将尝试暴破 ssh 密码的 IP 封停，有效防止暴力破解攻击。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> fail2ban</code></pre><p><strong>安装并配置 UFW 防火墙</strong></p><p>ufw，即 uncomplicated firewall（简单防火墙），是 Ubuntu 系统默认的防火墙组件，它可以简化对 iptables 的配置。</p><ul><li><p>如果未安装 ufw，则先进行安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> ufw</code></pre></li></ul><p>#Ubuntu 系统已经自带了 ufw 防火墙</p><ul><li><p>添加基本的 ufw 规则</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw allow http  <span class="token comment"># 允许 80 端口传入连接</span>ufw allow https  <span class="token comment"># 允许 443 端口传入连接</span>ufw allow <span class="token function">ssh</span>  <span class="token comment"># 允许 22 端口传入连接</span></code></pre></li><li><p>添加自定义端口</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw allow 端口号ufw allow <span class="token number">10000</span>:20000/tcp  <span class="token comment"># 此处指定了 10000 到 20000 的端口范围，并指定只允许 TCP 连接</span></code></pre></li><li><p>开启 ufw</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw <span class="token builtin class-name">enable</span></code></pre></li></ul><p>#会提示你可能影响 ssh 连接，务必确认已将你的 ssh 端口加入到 ufw rules 中，然后按 y 确认开启</p><ul><li><p>查看 ufw 状态</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw status</code></pre></li><li><p>删除某条规则</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw delete allow 端口号</code></pre></li></ul><h3 id="使用-NTP-同步系统时间"><a href="#使用-NTP-同步系统时间" class="headerlink" title="使用 NTP 同步系统时间"></a>使用 NTP 同步系统时间</h3><p>许多服务都要求服务器时间与标准时间误差不能过大，因此我们使用 NTP 进行时间同步。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> ntp</code></pre><p><strong>设置时区</strong></p><p>切换到与所在地相同的时区可以方便 crontab 等服务的设置。</p><p>查看可用时区列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl list-timezones</code></pre><p>设定时区：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl set-timezone Asia/Hong_Kong  <span class="token comment"># 将时区设置为 Asia/Hong_Kong</span></code></pre><p>查看当前时间设定：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl</code></pre><h3 id="配置无人值守更新（可选）"><a href="#配置无人值守更新（可选）" class="headerlink" title="配置无人值守更新（可选）"></a>配置无人值守更新（可选）</h3><p>一般来说，Ubuntu 系统已经自带了 <code>unattended-upgrades</code> 包；如果没有，则先安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> unattended-upgrades</code></pre><p>随后，通过以下命令启用无人值守更新：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"unattended-upgrades unattended-upgrades/enable_auto_updates boolean true"</span> <span class="token operator">|</span> debconf-set-selections<span class="token assign-left variable">DEBIAN_FRONTEND</span><span class="token operator">=</span>noninteractive dpkg-reconfigure unattended-upgrades</code></pre><p>通过编辑 <code>/etc/apt/apt.conf.d/</code> 下的 <code>20auto-upgrades</code> 和 <code>50unattended-upgrades</code> 两个配置文件，我们可以设定无人值守更新。</p><ul><li><p><code>/etc/apt/apt.conf.d/20auto-upgrades</code></p><pre class="language-Plain" data-language="Plain"><code class="language-Plain">APT::Periodic::Update-Package-Lists &quot;1&quot;;# 自动更新软件包列表周期（天），0 为关闭APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;# 自动下载可更新的软件包周期（天），0 为关闭APT::Periodic::AutocleanInterval &quot;0&quot;;# 自动清理周期（天），0 为关闭APT::Periodic::Unattended-Upgrade &quot;1&quot;;# 自动更新软件包周期（天），0 为关闭</code></pre></li><li><p><code>/etc/apt/apt.conf.d/50unattended-upgrades</code></p></li></ul><p>以下为一些关键的设置项：</p><pre class="language-fallback" data-language="fallback"><code class="language-fallback">Unattended-Upgrade::Allowed-Origins &#123;... ...&#x2F;&#x2F;&quot;$&#123;distro_id&#125;:$&#123;distro_codename&#125;-updates&quot;;&#x2F;&#x2F; 自动更新（除安全更新外的）软件包，去除行前的注释符号 &#x2F;&#x2F; 以开启&#x2F;&#x2F; 注意：开启此选项有风险    ... ...&#125;;... ...&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Kernel-Packages &quot;true&quot;;&#x2F;&#x2F; 自动移除无用内核，去除行前的注释符号 &#x2F;&#x2F; 以开启... ...&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Dependencies &quot;false&quot;;&#x2F;&#x2F; 自动移除无用依赖，去除行前的注释符号 &#x2F;&#x2F; 并将 false 改为 true 以开启&#x2F;&#x2F; 等同于自动 apt-get autoremove</code></pre><p>本配置文件还提供了许多其他的设置项，并且有详细的注释，可自行查看编辑。</p><h3 id="启用-Canonical-Livepatch-服务（可选）"><a href="#启用-Canonical-Livepatch-服务（可选）" class="headerlink" title="启用 Canonical Livepatch 服务（可选）"></a>启用 Canonical Livepatch 服务（可选）</h3><p>在 Ubuntu 16.04 及以上的系统中，可以使用 Canonical Livepatch 服务实现无需重启系统就能安装内核安全补丁。同时，Canonical Livepatch 服务对于不超过 3 台机器的个人用户是免费的。</p><ol><li><p>在 <a href="https://auth.livepatch.canonical.com/">Canonical Livepatch Service 官网</a> 上选择 <code>Ubuntu user</code>，点击 <code>Get your Livepatch token</code></p></li><li><p>按要求注册（或登录）Ubuntu One 账号，获取 token</p></li><li><p>ssh 到服务器上，随后安装 Snapd 守护程序：</p></li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> snapd</code></pre><ol start="4"><li>安装 Canonical Livepatch 守护程序：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">snap <span class="token function">install</span> canonical-livepatch</code></pre><ol start="5"><li>启用 Canonical Livepatch：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch <span class="token builtin class-name">enable</span> <span class="token operator">&lt;</span>token<span class="token operator">></span><span class="token comment"># 请自行将 &lt;token> 换成第二步中获取的 token</span></code></pre><ol start="6"><li>查看 Canonical Livepatch 状态：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch status</code></pre><ol start="7"><li>手动更新补丁：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch refresh</code></pre><ol start="8"><li>停用 Canonical Livepatch：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">snap run canonical-livepatch disable</code></pre><p><strong>注意</strong>：安装内核补丁与安装新内核不同，如果安装了新内核，则必须重新启动系统以应用新内核。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>提高文件并发数</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'* soft nofile 51200* hard nofile 51200'</span> <span class="token operator">>></span> /etc/security/limits.conf</code></pre><p>然后，执行：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">ulimit</span> -n <span class="token number">51200</span></code></pre><p><strong>设置虚拟内存</strong></p><p>某些 VPS 服务商会预先设置好虚拟内存，所以我们先查看系统当前可用内存：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">free</span> -m</code></pre><p>输出样例：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">free</span> -m              total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:            <span class="token number">982</span>         <span class="token number">277</span>         <span class="token number">112</span>           <span class="token number">1</span>         <span class="token number">592</span>         <span class="token number">533</span>Swap:          <span class="token number">1023</span>           <span class="token number">2</span>        <span class="token number">1021</span></code></pre><p>如果输出中没有上面的 <code>Swap</code> 一行或 <code>Swap</code> 后为 0，则表示系统没有设置虚拟内存，可以参考下面的方法设置：</p><ol><li>创建 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/root/swapfile <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1024</span><span class="token comment"># if 表示 input file (输入文件)，of 表示 output file (输出文件)，bs 表示 block size (块大小)，count 表示计数</span></code></pre><p>示例中采用的数据块大小为 1M，数据块计数为 1024，所以分配的空间就是 1G 大小。</p><ol start="2"><li>设置正确的 swapfile 权限</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> /root/swapfile</code></pre><ol start="3"><li>格式化 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkswap</span> /root/swapfile</code></pre><ol start="4"><li>启用 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">swapon</span> /root/swapfile</code></pre><ol start="5"><li>设置开机自动加载虚拟内存</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"/root/swapfile swap swap defaults 0 0"</span> <span class="token operator">>></span> /etc/fstab</code></pre><p>此时再执行 <code>free -m</code> 即可看到虚拟内存已经启用了。</p><h3 id="开启-BBR-拥塞控制算法"><a href="#开启-BBR-拥塞控制算法" class="headerlink" title="开启 BBR 拥塞控制算法"></a>开启 BBR 拥塞控制算法</h3><p>BBR 是 Google 出品的 TCP 拥塞控制算法，其目的是尽量跑满带宽，可以起到单边加速 TCP 连接的效果。BBR 是内嵌在 Linux 内核中的，而 Linux kernel 4.9 已加入了该算法。如果你的系统内核版本低于 4.9，则需要先升级 Linux 内核。<br>*# Ubuntu 18.04 及以上系统内核版本已高于 4.9，可直接开启 BBR*</p><ol><li>开启 BBR</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"net.core.default_qdisc=fq"</span> <span class="token operator">>></span> /etc/sysctl.conf<span class="token builtin class-name">echo</span> <span class="token string">"net.ipv4.tcp_congestion_control=bbr"</span> <span class="token operator">>></span> /etc/sysctl.conf</code></pre><p>然后，执行 <code>sysctl -p</code> 保存生效。</p><ol start="2"><li>查看 BBR 是否成功开启</li></ol><p>执行 <code>sysctl net.ipv4.tcp_available_congestion_control</code>， 结果中应有 <code>bbr</code>。<br>执行 <code>lsmod | grep bbr</code>，结果中应有 <code>tcp_bbr</code>。</p><p><strong>自动升级内核</strong></p><p>默认情况下，Ubuntu LTS 将保持在最初发布的 Linux 内核上。而 Ubuntu 硬件支持栈（<strong>H</strong>ard<strong>w</strong>are <strong>E</strong>nablement Stacks, HWE）可以为现有的 Ubuntu LTS 提供更新的内核支持，实现内核自动升级，方便我们体验较新内核的特性[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref10">10]</a>。</p><ol><li>查看当前系统内核版本</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> -r</code></pre><ol start="2"><li>安装 HWE</li></ol><p>使用包管理器即可安装 HWE：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> --install-recommends linux-generic-hwe-20.04  <span class="token comment"># For Ubuntu 20.04 LTS</span><span class="token function">apt</span> <span class="token function">install</span> --install-recommends linux-generic-hwe-18.04  <span class="token comment"># For Ubuntu 18.04 LTS</span></code></pre><ol start="3"><li>重启系统以应用新内核</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">reboot</span></code></pre><ol start="4"><li>删除旧内核（可选）[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref11">11]</a></li></ol><p>使用包管理器自动卸载即可：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> autoremove --purge</code></pre><p>如果只想保留当前最新的内核，可以使用以下命令<strong>（有风险，慎用）</strong>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token variable"><span class="token variable">$(</span>dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">"linux-(image|headers|modules)"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v hwe <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token punctuation">$(</span>uname -r <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">'-'</span> -f1,2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print <span class="token variable">$2</span>&#125;'</span><span class="token variable">)</span></span></code></pre><p>或者也可以手动卸载：</p><p><strong>卸载旧版 linux-image：</strong></p><p>获取 linux-image 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-image</code></pre><p>卸载旧版 linux-image：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-image名<span class="token operator">></span></code></pre><p><strong>卸载旧版 linux-headers：</strong></p><p>获取 linux-headers 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-headers</code></pre><p>卸载旧版 linux-headers：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-headers名<span class="token operator">></span></code></pre><p><strong>卸载旧版 linux-modules：</strong></p><p>获取 linux-modules 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-modules</code></pre><p>卸载旧版 linux-modules：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-modules名<span class="token operator">></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>安装 Docker-CE</strong></p><p><a href="https://www.docker.com/">Docker</a> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。iOS 上的 <a href="https://www.hyperapp.fun/zh/">HyperApp</a> 也正是借助 Docker 实现了自动部署应用。</p><p>安装 Docker 最方便的方式是使用官方脚本[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref12">12]</a>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO- get.docker.com <span class="token operator">|</span> <span class="token function">bash</span></code></pre><p>对于国内 VPS，还可以指定使用阿里云镜像进行安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO- get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> -s docker --mirror Aliyun</code></pre><p><strong>以普通用户管理 Docker</strong></p><p>由于 Docker 守护进程绑定在 Unix socket 上，而 Unix socket 默认仅属于 <code>root</code> 用户，因此在通过普通用户管理 Docker 时，我们需要在命令前加上 <code>sudo</code>。为了方便使用，我们可以将普通用户添加到 <code>docker</code> 用户组中，这样就能直接使用 <code>docker</code> 命令而不需要 <code>sudo</code>。</p><ol><li>创建 <code>docker</code> 用户组</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">groupadd</span> docker<span class="token comment"># 较新的 Docker 安装中可能已经添加了 docker 用户组</span></code></pre><ol start="2"><li>将当前用户加入 <code>docker</code> 组</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gpasswd -a <span class="token environment constant">$USER</span> docker</code></pre><ol start="3"><li>登出并重新登入当前用户</li></ol><p>或者，你也可以使用 <code>newgrp</code> 命令以 <code>docker</code> 组重新登入系统：</p><pre class="language-bash" data-language="bash"><code class="language-bash">newgrp docker</code></pre><p>此时就可以直接使用 <code>docker</code> 命令管理容器了。</p><p><strong>限制 Docker 容器日志大小</strong></p><p>Docker 容器运行过程中会产生大量日志文件，如果不加限制可能会导致 VPS 磁盘空间不足。通过编辑 Docker 配置文件，我们可以限制容器日志大小。</p><p>编辑 <code>/etc/docker/daemon.json</code> 文件：<code>vim /etc/docker/daemon.json</code></p><p>添加 <code>log-dirver</code>和 <code>log-opts</code> 参数：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">"json-file"</span><span class="token punctuation">,</span>  <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"50m"</span><span class="token punctuation">,</span> <span class="token property">"max-file"</span><span class="token operator">:</span> <span class="token string">"3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>#样例中一个容器的日志大小上限是 50 M，最多创建 3 个日志文件</p><p>对于国内 VPS，还可以在配置文件中配置国内镜像源：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">"json-file"</span><span class="token punctuation">,</span>  <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"50m"</span><span class="token punctuation">,</span> <span class="token property">"max-file"</span><span class="token operator">:</span> <span class="token string">"3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://&lt;阿里云ID>.mirror.aliyuncs.com"</span><span class="token punctuation">,</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>#阿里云源地址可以在 <a href="https://cr.console.aliyun.com/">容器镜像服务</a> &gt; 镜像加速器 下查看</p><p>保存退出，随后加载配置文件并重启 Docker：</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reloadsystemctl restart docker</code></pre><p>#设置的日志大小，只对新建的容器有效</p><p><strong>手动清理 Docker 容器日志</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">docker <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;if (NR>1)&#123;print <span class="token variable">$1</span>&#125;&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> docker inspect --format<span class="token operator">=</span><span class="token string">'&#123;&#123;.LogPath&#125;&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> truncate -s <span class="token number">0</span></code></pre><p><strong>解决 UFW 对 Docker 容器无效的问题</strong></p><p>在使用 Docker 暴露容器端口时，Docker 会直接操作 iptables NAT 规则，导致 ufw 无法管理 Docker 所发布的端口，这是一个严重的安全问题。好在通过编辑 ufw 的 <code>after.rules</code>，我们能够解决这一问题。</p><p>编辑 ufw 的 <code>after.rules</code>：<code>vim /etc/ufw/after.rules</code></p><p>在末尾写入如下内容：</p><pre class="language-Plain" data-language="Plain"><code class="language-Plain"># BEGIN UFW AND DOCKER*filter:ufw-user-forward - [0:0]:DOCKER-USER - [0:0]-A DOCKER-USER -j RETURN -s 10.0.0.0&#x2F;8-A DOCKER-USER -j RETURN -s 172.16.0.0&#x2F;12-A DOCKER-USER -j RETURN -s 192.168.0.0&#x2F;16-A DOCKER-USER -j ufw-user-forward-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0&#x2F;16-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0&#x2F;8-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0&#x2F;12-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0&#x2F;16-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0&#x2F;8-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0&#x2F;12-A DOCKER-USER -j RETURNCOMMIT# END UFW AND DOCKER</code></pre><p>保存退出，随后重启 ufw：</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl restart ufw</code></pre><p><em># 如果重启 ufw 之后规则没有生效，则需要重启服务器。</em></p><p>如果你要允许外部网络访问所有 Docker 发布的、内部端口为 <code>80</code> 的服务，则执行：</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw route allow from any to any port <span class="token number">80</span>ufw route allow proto tcp from any to any port <span class="token number">80</span>  <span class="token comment"># 仅允许 TCP 协议</span></code></pre><p><em># 此处的 <code>80</code> 是容器内部端口，而非使用 <code>-p 8080:80</code> 选项发布在服务器上的 <code>8080</code> 端口。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文内容适用于 Ubuntu 系统；部分本地操作以在 macOS 下完成为例。&lt;/p&gt;
&lt;p&gt;本文部分命令需要以 &lt;code&gt;root&lt;/code&gt; 用户或 &lt;code&gt;sudo&lt;/code&gt; 权限执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr</summary>
      
    
    
    
    
    <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
