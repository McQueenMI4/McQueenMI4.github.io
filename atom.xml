<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-10T08:03:41.483Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>McQueenMI4</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS 8 系统初始化</title>
    <link href="http://yoursite.com/2020/09/10/CentOS%208%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96.html"/>
    <id>http://yoursite.com/2020/09/10/CentOS%208%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96.html</id>
    <published>2020-09-10T04:22:22.000Z</published>
    <updated>2020-09-10T08:03:41.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat /etc/system-release </span>CentOS Linux release <span class="token number">8.0</span>.1905 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span> </code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># firewall-cmd --list-all</span>public <span class="token punctuation">(</span>active<span class="token punctuation">)</span>  target: default  icmp-block-inversion: no  interfaces: enp0s3  sources:  services: cockpit dhcpv6-client <span class="token function">ssh</span>  ports:  protocols:  masquerade: no  forward-ports:  source-ports:  icmp-blocks:  rich rules: </code></pre><h2 id="创建一个新用户"><a href="#创建一个新用户" class="headerlink" title="创建一个新用户"></a>创建一个新用户</h2><p>当你使用 root 登录到服务器，我们一般都是新建一个普通用户。本文以用户 <code>admin</code> 为例。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># adduser admin</span></code></pre><p>下一步，设置这个用户的密码。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># passwd admin</span></code></pre><p>输入密码，并再次输入进行确认。</p><h2 id="Root-权限"><a href="#Root-权限" class="headerlink" title="Root 权限"></a>Root 权限</h2><p>现在，我们有了普通用户，进行普通的操作，但是有时，我们需要更大的权限进行操作，如 <code>yum update</code>，进行这样的操作，我们一般不会使用 root 登进登录，一般使用 <code>sudo</code> （Super User do）命令。</p><p>为了将 <code>sudo</code> 权限给普通用户，我们需要将新用户加入 <code>wheel</code> 组中，CentOS 默认的 wheel 组有运行 <code>sudo</code> 的权限。</p><p>我们使用 root 用户，将 admin 用户加入到 wheel 组中。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># gpasswd -a admin wheel</span></code></pre><p>现在，admin 用户可以使用超级用户的权限运行各种命令了。</p><h2 id="添加服务器的公钥授权"><a href="#添加服务器的公钥授权" class="headerlink" title="添加服务器的公钥授权"></a>添加服务器的公钥授权</h2><p>如果客户端想访问服务端，可以使用 ssh 命令，SSH 支持用户名和密码方式，也支持公钥授权。</p><p>一般是在本机（客户端）新建一对 SSH key（包含公钥和私钥）,将公钥放入服务器（服务端）的 autohrized_keys 中，这样安全性更高些。</p><p><strong>成一对密钥</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C z196@gmail.com</code></pre><p>这里使用命令参数 <code>-t</code> 指定了密钥的算法，<code>-C</code> 指定了密钥的注释</p><p>执行命令之后，会在 <code>$HOME</code> 下的 .ssh 目录下生成 2 个文件，<code>id_rsa</code> 为私钥，<code>id_rsa.pub</code> 为公钥。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> ~/.ssh/id_rsa  id_rsa.pub</code></pre><p><strong>拷贝公钥到服务器</strong></p><p>生成 SSH 密钥对之后，您需要将本地（客户端）的公钥，拷贝到服务器（服务端）</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ssh-copy-id 用户@IP</code></pre><p>这会将本地用户的公钥拷贝到服务端的 admin 用户的 <code>.ssh/authorized_keys</code> 文件中。</p><h2 id="配置-SSH-服务"><a href="#配置-SSH-服务" class="headerlink" title="配置 SSH 服务"></a>配置 SSH 服务</h2><p>我们添加了普通用户，也可以执行 sudo 命令，需要配置 ssh 服务，去掉 root 用户的远程登录，这样更加安全。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/ssh/sshd_config</code></pre><p>将</p><pre class="language-vim" data-language="vim"><code class="language-vim">#PermitRootLogin yes</code></pre><p>改为</p><p><code>#PermitRootLogin no</code></p><p><code>:wq</code> 之后，保存退出。</p><p>重启 ssh 服务</p><pre class="language-BASH" data-language="BASH"><code class="language-BASH">$ sudo systemctl reload sshd</code></pre><p>服务器的 root 用户就被禁止了远程登录。</p><p>注：</p><pre class="language-vi" data-language="vi"><div class="caption"><span>m</span></div><code class="language-vi">PermitRootLogin yes  #允许root用户以任何认证方式登录（貌似也就两种认证方式：用户名密码认证，公钥认证）PermitRootLogin without-password      #只允许root用public key认证方式登录PermitRootLogin no                    #不允许root用户以任何认证方式登录</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux SSH 超时断开连接解决方法</title>
    <link href="http://yoursite.com/2020/09/09/Linux%20SSH%20%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html"/>
    <id>http://yoursite.com/2020/09/09/Linux%20SSH%20%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</id>
    <published>2020-09-09T14:33:29.000Z</published>
    <updated>2020-09-09T16:40:12.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><strong>防火墙</strong></p><p><em>1. 服务器存在防火墙，会关闭超时空闲连接，或设置了关闭超时空闲连接。</em><br><em>2. 客服端和服务器之间存在路由器，路由器也可能带有防火墙，会关闭超时空闲连接。</em><br><em>3. 客服端存在防火墙，会关闭超时空闲连接。</em></p><p>在iptables的一些NAT配置说明里有提到</p><blockquote><p>4.3.6 State match 状态匹配扩展要有内核里的连接跟踪代码的协助，因为它是从连接跟踪机制中得到包的状态的。这样我们就可以了解连接所处的状态。它几乎适用于所有的协议，包括那些无状态的协议，如ICMP和UDP。<strong>针对每个连接都有一个缺省的超时值，如果连接的时间超过了这个值，那么这个连接的记录就被会从连接跟踪的记录数据库中删除，也就是说连接就不再存在了。</strong>这个match必须有-m state作为前提才能使用。状态机制的详细内容在章节状态机制中。</p><p>NAT firewalls like to time out idle sessions to keep their state tables clean and their memory footprint low.<br><strong>NAT防火墙喜欢对空闲的会话进行超时处理，以确保它们状态表的干净和内存的低占用率。</strong><br>Some firewalls are nice, and let you idle for up to a day or so; some are gestapo and terminate your session after 5 minutes.<br><strong>一些防火墙比较友好，允许你的空闲会话时间为一天甚至超过一天；另一些却如盖世太保，5分钟空闲就终止你的会话。</strong></p></blockquote><p><strong>通过ssh连接后，客户端和服务端长时间没响应时，在两方机器设置中均没任何限制，但在各自的防火墙，或是中转网络连接路由的防火墙中，出现了「闲置超时断开」的缺省机制。</strong></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p><strong>让连接（忙）起来，别（闲）着！</strong></p><h2 id="修改服务端配置"><a href="#修改服务端配置" class="headerlink" title="修改服务端配置"></a>修改服务端配置</h2><p><code>vim /etc/ssh/sshd_config</code></p><p><img src="https://raw.githubusercontent.com/McQueenMI4/photo/master/img/%E6%88%AA%E5%B1%8F2020-09-09%20%E4%B8%8B%E5%8D%8810.49.47.png" alt="服务端配置" loading="lazy"></p><p><code>TCPKeepAlive yes</code> #表示TCP保持连接不断开<br><code>ClientAliveInterval 300</code> #指定服务端向客户端请求消息的时间间隔，单位是秒，默认是0，不发送。设置个300表示5分钟发送一次（注意，这里是服务端主动发起），然后等待客户端响应，成功，则保持连接。<br><code>ClientAliveCountMax 3</code> #指服务端发出请求后客户端无响应则自动断开的最大次数。使用默认给的3即可。<br>（注意：TCPKeepAlive必须打开，否则直接影响后面的设置。ClientAliveInterval设置的值要小于各层防火墙的最小值，不然，也就没用了。）</p><p>注意：最后要重启sshd服务才生效<br><code>sudo /etc/init.d/ssh restart</code></p><p>修改服务端的配置往往会比较麻烦，也涉及到权限问题，以及安全问题。还是比较推荐下面的方法。</p><h2 id="修改客户端配置"><a href="#修改客户端配置" class="headerlink" title="修改客户端配置"></a>修改客户端配置</h2><p><code>vim ~/.ssh/config</code></p><pre class="language-bash" data-language="bash"><code class="language-bash">Host *    ServerAliveInterval <span class="token number">60</span></code></pre><p><code>Host *</code> #表示需要启用该规则的服务端（域名或ip）<br><code>ServerAliveInterval 60</code> #表示没60秒去给服务端发起一次请求消息（这个设置好就行了）<br><code>ServerAliveCountMax 3</code> #表示最大连续尝试连接次数（这个基本不用设置）</p><h2 id="修改连接工具的配置"><a href="#修改连接工具的配置" class="headerlink" title="修改连接工具的配置"></a>修改连接工具的配置</h2><p>通过改变连接工具的一些默认配置，把keepalive的配置打开起来即可：</p><ul><li>secureCRT：会话选项 - 终端 - 反空闲 - 发送NO-OP每xxx秒，设置一个非0值。</li><li>putty：Connection - Seconds between keepalive(0 to turn off)，设置一个非0值。</li><li>iTerm2：profiles - sessions - When idle - send ASCII code.</li><li>XShell：session properties - connection - Keep Alive - Send keep alive message while this session connected. Interval [xxx] sec.</li></ul><p>当然，用这个办法的副作用也是有的，比如iTerm2会出现一些并不想输入的字符、vim会有些多余字符插入等等，这些情况就按个人的需要酌情取舍了。</p><h2 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h2><p><code>ssh -o ServerAliveInterval=30 用户名@IP</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>V2Ray搭建</title>
    <link href="http://yoursite.com/2020/09/08/V2Ray%E6%90%AD%E5%BB%BA.html"/>
    <id>http://yoursite.com/2020/09/08/V2Ray%E6%90%AD%E5%BB%BA.html</id>
    <published>2020-09-08T11:21:57.000Z</published>
    <updated>2020-09-08T16:18:05.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>部署V2Ray使用的GitHub地址</p><p><a href="https://github.com/233boy/v2ray">https://github.com/233boy/v2ray</a></p></blockquote><h1 id="校准标准时间"><a href="#校准标准时间" class="headerlink" title="校准标准时间"></a>校准标准时间</h1><p><strong>执行命令 <code>date -R</code> 查看时间</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> -R</code></pre><p><strong>使用 NTP 同步系统时间</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> ntp</code></pre><p><strong>设置时区</strong></p><p>切换到与所在地相同的时区可以方便 crontab 等服务的设置。</p><p>查看可用时区列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl list-timezones</code></pre><p>设定时区：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl set-timezone Asia/Hong_Kong  <span class="token comment"># 将时区设置为 Asia/Hong_Kong</span></code></pre><p>查看当前时间设定：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl</code></pre><h1 id="安装-V2Ray"><a href="#安装-V2Ray" class="headerlink" title="安装 V2Ray"></a>安装 V2Ray</h1><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -s -L https://git.io/v2ray.sh<span class="token punctuation">)</span></code></pre><ol><li><p>选择传输协议，如果没有特别的需求，使用默认的 TCP 传输协议即可，直接回车。选择端口，如果没有特别的需求，使用默认的端口即可，直接回车。是否屏蔽广告，除非你真的需要，一般来说，直接回车即可。</p></li><li><p>是否配置 Shadowsocks ，如果不需要就直接回车，否则就输入 Y 回车，Shadowsocks 端口，密码，加密方式这些东西自己看情况配置。</p></li></ol><h1 id="快速管理-V2Ray"><a href="#快速管理-V2Ray" class="headerlink" title="快速管理 V2Ray"></a>快速管理 V2Ray</h1><p>   <code>v2ray info</code> 查看 V2Ray 配置信息<br>   <code>v2ray config</code> 修改 V2Ray 配置<br>   <code>v2ray link</code> 生成 V2Ray 配置文件链接<br>   <code>v2ray infolink</code> 生成 V2Ray 配置信息链接<br>   <code>v2ray qr</code> 生成 V2Ray 配置二维码链接<br>   <code>v2ray ss</code> 修改 Shadowsocks 配置<br>   <code>v2ray ssinfo</code> 查看 Shadowsocks 配置信息<br>   <code>v2ray ssqr</code> 生成 Shadowsocks 配置二维码链接<br>   <code>v2ray status</code> 查看 V2Ray 运行状态<br>   <code>v2ray start</code> 启动 V2Ray<br>   <code>v2ray stop</code> 停止 V2Ray<br>   <code>v2ray restart</code> 重启 V2Ray<br>   <code>v2ray log</code> 查看 V2Ray 运行日志<br>   <code>v2ray update</code> 更新 V2Ray<br>   <code>v2ray update.sh</code> 更新 V2Ray 管理脚本<br>   <code>v2ray uninstall</code> 卸载 V2Ray</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>VPS配置</title>
    <link href="http://yoursite.com/2020/09/04/VPS%E9%85%8D%E7%BD%AE.html"/>
    <id>http://yoursite.com/2020/09/04/VPS%E9%85%8D%E7%BD%AE.html</id>
    <published>2020-09-04T05:45:11.000Z</published>
    <updated>2020-09-09T14:36:22.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文内容适用于 Ubuntu 系统；部分本地操作以在 macOS 下完成为例。</p><p>本文部分命令需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行。</p></blockquote><hr><h3 id="SSH-安全"><a href="#SSH-安全" class="headerlink" title="SSH 安全"></a>SSH 安全</h3><p>为了避免 VPS 被 ssh 弱口令扫描，用公私钥对进行 ssh 登录，并关闭密码登录。</p><p><strong>生成并添加密钥</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t ed25519  <span class="token comment"># ED25519 算法，长度固定为 256 bits，安全性和性能最佳，兼容性稍差</span><span class="token comment"># 或者</span>ssh-keygen -t rsa -b <span class="token number">2048</span>  <span class="token comment"># RSA 算法，指定密钥长度为 2048 bits，兼容性最佳</span></code></pre><p>提示 <code>Enter file in which to save the key (/Users/~/.ssh/id_ed25519):</code><br><em># 使用默认文件位置，直接回车即可</em></p><p>提示 <code>Enter passphrase (empty for no passphrase):</code><br><em># 设置私钥的密码（留空即为免密码）</em></p><p>提示 <code>Enter same passphrase again:</code><br><em># 再次输入私钥的密码</em></p><p>此时就已经在 <code>~/.ssh/</code> 下生成了 <code>id_ed25519 (或 id_rsa)</code> (私钥) 和 <code>id_ed25519.pub (或 id_rsa.pub)</code> (公钥) 两个文件。</p><p><strong>在服务器端添加公钥</strong></p><p>使用 scp 命令将公钥上传到服务器：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> ~/.ssh/id_ed25519.pub root@<span class="token operator">&lt;</span>VPS域名或IP<span class="token operator">></span>:/root/</code></pre><p>#输入 ssh 密码并回车确认</p><p>ssh 到服务器上，随后执行</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">mv</span> id_ed25519.pub ~/.ssh <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> ~/.ssh<span class="token function">mv</span> id_ed25519.pub authorized_keys <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> <span class="token number">600</span> authorized_keys</code></pre><p>此时就可以使用密钥进行 ssh 登录了。</p><p><strong>macOS 本地配置</strong></p><p>如果不想每次使用密钥登录时都要输入密码，那么你可以编辑 ssh 配置文件将密码存储到钥匙串：</p><p>编辑 ssh 配置文件：<code>vim ~/.ssh/config</code></p><pre class="language-vim" data-language="vim"><code class="language-vim">Host <span class="token operator">*</span>  AddKeysToAgent yes  # 用 ssh<span class="token operator">-</span>agent 管理密钥  UseKeychain yes  # 将密码存储到钥匙串中  IdentityFile ~<span class="token operator">/</span><span class="token operator">.</span>ssh<span class="token operator">/</span>id_ed25519  # 指定私钥路径</code></pre><p>ssh报错，清除原有ssh密钥<code>ssh-keygen -R vpsIP</code></p><p>如果你想通过代理 ssh 到你的服务器，那么再写入如下内容：</p><pre class="language-Plain" data-language="Plain"><code class="language-Plain">Host &lt;VPS域名或IP&gt;  ProxyCommand nc -X 5 -x 127.0.0.1:6153 %h %p# nc, netcat# -X 5, 指定使用 SOCKS5 代理# -x, 指定代理的主机地址和端口，示例中为本机的 6153 端口# %h %p, 用于替换 ssh 实际连接的主机地址和端口</code></pre><p><strong>关闭 ssh 的密码登录 &amp; 防止 Broken pipe 错误</strong></p><p>设置好密钥登录后，我们就可以关闭 ssh 的密码登录了。同时，为了避免在使用 ssh 时空闲连接时间过长而导致 <code>Write failed: Broken pipe</code> 错误，我们可以在 ssh 配置文件中设置 <code>ClientAliveInterval</code> 参数，这会允许服务器在一定时间内发送一个特定的包给客户端，一旦超时，则说明断线，就关闭连接，避免了空闲连接时间过长报错。</p><p>编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code>将<code>PasswordAuthentication yes</code> 改为 <code>PasswordAuthentication no</code>，并去除行前的注释符号 <code>#</code><br>将 <code>ClientAliveInterval</code> 一行改为 <code>ClientAliveInterval 60</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="创建普通用户并授予-sudo-权限"><a href="#创建普通用户并授予-sudo-权限" class="headerlink" title="创建普通用户并授予 sudo 权限"></a>创建普通用户并授予 sudo 权限</h3><p><strong>创建用户</strong></p><p>首先，使用 <code>useradd</code> 命令创建用户：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> -m -s /bin/bash <span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token comment"># 添加用户名为 &lt;username> 的用户</span><span class="token comment"># -m, 自动创建用户家目录，并将 /etc/skel 中的文件复制到家目录中</span><span class="token comment"># -s /bin/bash, 指定用户默认 shell 为 bash</span></code></pre><p>然后为该用户设置密码：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span> <span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p><strong>授予用户 sudo 权限</strong></p><p>一般来说，Ubuntu 系统已经自带了 <code>sudo</code>；如果没有，则先安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">sudo</span></code></pre><p>由于直接修改 <code>etc/sudoers</code> 文件有一定的危险性，因此我们采用将配置文件追加到 <code>/etc/sudoers.d/</code> 目录下的方式进行配置。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'&lt;username> ALL=(ALL) ALL'</span> <span class="token operator">>></span> /etc/sudoers.d/<span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token comment"># 请自行将 &lt;username> 改为你的用户名</span></code></pre><p><code>&lt;username&gt; ALL=(ALL) ALL</code> 表示普通用户 <code>&lt;username&gt;</code> 可以在任何主机上，通过 <code>sudo</code> 提权到任何用户/用户组，执行任何命令[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref04">4]</a>。</p><p>如果你想免密使用 <code>sudo</code><strong>（不安全）</strong>，那么上一步可以改为：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'&lt;username> ALL=(ALL) NOPASSWD: ALL'</span> <span class="token operator">>></span> /etc/sudoers.d/<span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p><strong>解决部分机器 sudo 提示 unable to resolve host</strong></p><p>部分服务器在执行 <code>sudo</code> 时，会弹出以下错误：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token boolean">true</span>sudo: unable to resolve <span class="token function">host</span> <span class="token operator">&lt;</span>hostname<span class="token operator">></span></code></pre><p>尽管不影响使用，但看着总让人不爽。这个错误是因为服务商提供的默认系统镜像没有将主机名 (hostname) 添加到 <code>/etc/hosts</code> 文件中，导致系统无法解析 hostname。使用以下命令即可解决：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"127.0.0.1 <span class="token variable"><span class="token variable">$(</span><span class="token function">hostname</span><span class="token variable">)</span></span>"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> -a /etc/hosts</code></pre><p><strong>为用户启用 SSH</strong></p><p>首先切换到刚刚创建的用户：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">su</span> - <span class="token operator">&lt;</span>username<span class="token operator">></span></code></pre><p>随后，建立 <code>~/.ssh</code> 目录，并将 <code>root</code> 用户下的 <code>authorized_keys</code> 复制过来：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/.ssh/<span class="token function">sudo</span> <span class="token function">cp</span> /root/.ssh/authorized_keys ~/.ssh/</code></pre><p>最后设置正确的访问权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> -R <span class="token operator">&lt;</span>username<span class="token operator">></span>:<span class="token operator">&lt;</span>username<span class="token operator">></span> ~/.ssh<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys</code></pre><p>为了提高安全性，你还可以关闭 <code>root</code> 用户的 ssh 登录。编辑 ssh 配置文件：<code>vim /etc/ssh/sshd_config</code></p><p>将 <code>PermitRootLogin yes</code> 改为 <code>PermitRootLogin no</code>，并去除行前的注释符号 <code>#</code><br>保存退出，执行 <code>/etc/init.d/ssh restart</code> 重启 ssh 服务即可。</p><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p><strong>安装 fail2ban</strong></p><p>fail2ban 是 Linux 上一个著名的入侵保护的开源框架，它能通过 iptables 将尝试暴破 ssh 密码的 IP 封停，有效防止暴力破解攻击。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> fail2ban</code></pre><p><strong>安装并配置 UFW 防火墙</strong></p><p>ufw，即 uncomplicated firewall（简单防火墙），是 Ubuntu 系统默认的防火墙组件，它可以简化对 iptables 的配置。</p><ul><li><p>如果未安装 ufw，则先进行安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> ufw</code></pre></li></ul><p>#Ubuntu 系统已经自带了 ufw 防火墙</p><ul><li><p>添加基本的 ufw 规则</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw allow http  <span class="token comment"># 允许 80 端口传入连接</span>ufw allow https  <span class="token comment"># 允许 443 端口传入连接</span>ufw allow <span class="token function">ssh</span>  <span class="token comment"># 允许 22 端口传入连接</span></code></pre></li><li><p>添加自定义端口</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw allow 端口号ufw allow <span class="token number">10000</span>:20000/tcp  <span class="token comment"># 此处指定了 10000 到 20000 的端口范围，并指定只允许 TCP 连接</span></code></pre></li><li><p>开启 ufw</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw <span class="token builtin class-name">enable</span></code></pre></li></ul><p>#会提示你可能影响 ssh 连接，务必确认已将你的 ssh 端口加入到 ufw rules 中，然后按 y 确认开启</p><ul><li><p>查看 ufw 状态</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw status</code></pre></li><li><p>删除某条规则</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw delete allow 端口号</code></pre></li></ul><h3 id="使用-NTP-同步系统时间"><a href="#使用-NTP-同步系统时间" class="headerlink" title="使用 NTP 同步系统时间"></a>使用 NTP 同步系统时间</h3><p>许多服务都要求服务器时间与标准时间误差不能过大，因此我们使用 NTP 进行时间同步。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> ntp</code></pre><p><strong>设置时区</strong></p><p>切换到与所在地相同的时区可以方便 crontab 等服务的设置。</p><p>查看可用时区列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl list-timezones</code></pre><p>设定时区：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl set-timezone Asia/Hong_Kong  <span class="token comment"># 将时区设置为 Asia/Hong_Kong</span></code></pre><p>查看当前时间设定：</p><pre class="language-bash" data-language="bash"><code class="language-bash">timedatectl</code></pre><h3 id="配置无人值守更新（可选）"><a href="#配置无人值守更新（可选）" class="headerlink" title="配置无人值守更新（可选）"></a>配置无人值守更新（可选）</h3><p>一般来说，Ubuntu 系统已经自带了 <code>unattended-upgrades</code> 包；如果没有，则先安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> unattended-upgrades</code></pre><p>随后，通过以下命令启用无人值守更新：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"unattended-upgrades unattended-upgrades/enable_auto_updates boolean true"</span> <span class="token operator">|</span> debconf-set-selections<span class="token assign-left variable">DEBIAN_FRONTEND</span><span class="token operator">=</span>noninteractive dpkg-reconfigure unattended-upgrades</code></pre><p>通过编辑 <code>/etc/apt/apt.conf.d/</code> 下的 <code>20auto-upgrades</code> 和 <code>50unattended-upgrades</code> 两个配置文件，我们可以设定无人值守更新。</p><ul><li><p><code>/etc/apt/apt.conf.d/20auto-upgrades</code></p><pre class="language-Plain" data-language="Plain"><code class="language-Plain">APT::Periodic::Update-Package-Lists &quot;1&quot;;# 自动更新软件包列表周期（天），0 为关闭APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;# 自动下载可更新的软件包周期（天），0 为关闭APT::Periodic::AutocleanInterval &quot;0&quot;;# 自动清理周期（天），0 为关闭APT::Periodic::Unattended-Upgrade &quot;1&quot;;# 自动更新软件包周期（天），0 为关闭</code></pre></li><li><p><code>/etc/apt/apt.conf.d/50unattended-upgrades</code></p></li></ul><p>以下为一些关键的设置项：</p><pre class="language-fallback" data-language="fallback"><code class="language-fallback">Unattended-Upgrade::Allowed-Origins &#123;... ...&#x2F;&#x2F;&quot;$&#123;distro_id&#125;:$&#123;distro_codename&#125;-updates&quot;;&#x2F;&#x2F; 自动更新（除安全更新外的）软件包，去除行前的注释符号 &#x2F;&#x2F; 以开启&#x2F;&#x2F; 注意：开启此选项有风险    ... ...&#125;;... ...&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Kernel-Packages &quot;true&quot;;&#x2F;&#x2F; 自动移除无用内核，去除行前的注释符号 &#x2F;&#x2F; 以开启... ...&#x2F;&#x2F;Unattended-Upgrade::Remove-Unused-Dependencies &quot;false&quot;;&#x2F;&#x2F; 自动移除无用依赖，去除行前的注释符号 &#x2F;&#x2F; 并将 false 改为 true 以开启&#x2F;&#x2F; 等同于自动 apt-get autoremove</code></pre><p>本配置文件还提供了许多其他的设置项，并且有详细的注释，可自行查看编辑。</p><h3 id="启用-Canonical-Livepatch-服务（可选）"><a href="#启用-Canonical-Livepatch-服务（可选）" class="headerlink" title="启用 Canonical Livepatch 服务（可选）"></a>启用 Canonical Livepatch 服务（可选）</h3><p>在 Ubuntu 16.04 及以上的系统中，可以使用 Canonical Livepatch 服务实现无需重启系统就能安装内核安全补丁。同时，Canonical Livepatch 服务对于不超过 3 台机器的个人用户是免费的。</p><ol><li><p>在 <a href="https://auth.livepatch.canonical.com/">Canonical Livepatch Service 官网</a> 上选择 <code>Ubuntu user</code>，点击 <code>Get your Livepatch token</code></p></li><li><p>按要求注册（或登录）Ubuntu One 账号，获取 token</p></li><li><p>ssh 到服务器上，随后安装 Snapd 守护程序：</p></li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> snapd</code></pre><ol start="4"><li>安装 Canonical Livepatch 守护程序：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">snap <span class="token function">install</span> canonical-livepatch</code></pre><ol start="5"><li>启用 Canonical Livepatch：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch <span class="token builtin class-name">enable</span> <span class="token operator">&lt;</span>token<span class="token operator">></span><span class="token comment"># 请自行将 &lt;token> 换成第二步中获取的 token</span></code></pre><ol start="6"><li>查看 Canonical Livepatch 状态：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch status</code></pre><ol start="7"><li>手动更新补丁：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">canonical-livepatch refresh</code></pre><ol start="8"><li>停用 Canonical Livepatch：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">snap run canonical-livepatch disable</code></pre><p><strong>注意</strong>：安装内核补丁与安装新内核不同，如果安装了新内核，则必须重新启动系统以应用新内核。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>提高文件并发数</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'* soft nofile 51200* hard nofile 51200'</span> <span class="token operator">>></span> /etc/security/limits.conf</code></pre><p>然后，执行：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">ulimit</span> -n <span class="token number">51200</span></code></pre><p><strong>设置虚拟内存</strong></p><p>某些 VPS 服务商会预先设置好虚拟内存，所以我们先查看系统当前可用内存：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">free</span> -m</code></pre><p>输出样例：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">free</span> -m              total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:            <span class="token number">982</span>         <span class="token number">277</span>         <span class="token number">112</span>           <span class="token number">1</span>         <span class="token number">592</span>         <span class="token number">533</span>Swap:          <span class="token number">1023</span>           <span class="token number">2</span>        <span class="token number">1021</span></code></pre><p>如果输出中没有上面的 <code>Swap</code> 一行或 <code>Swap</code> 后为 0，则表示系统没有设置虚拟内存，可以参考下面的方法设置：</p><ol><li>创建 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/root/swapfile <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1024</span><span class="token comment"># if 表示 input file (输入文件)，of 表示 output file (输出文件)，bs 表示 block size (块大小)，count 表示计数</span></code></pre><p>示例中采用的数据块大小为 1M，数据块计数为 1024，所以分配的空间就是 1G 大小。</p><ol start="2"><li>设置正确的 swapfile 权限</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> /root/swapfile</code></pre><ol start="3"><li>格式化 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkswap</span> /root/swapfile</code></pre><ol start="4"><li>启用 swapfile</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">swapon</span> /root/swapfile</code></pre><ol start="5"><li>设置开机自动加载虚拟内存</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"/root/swapfile swap swap defaults 0 0"</span> <span class="token operator">>></span> /etc/fstab</code></pre><p>此时再执行 <code>free -m</code> 即可看到虚拟内存已经启用了。</p><h3 id="开启-BBR-拥塞控制算法"><a href="#开启-BBR-拥塞控制算法" class="headerlink" title="开启 BBR 拥塞控制算法"></a>开启 BBR 拥塞控制算法</h3><p>BBR 是 Google 出品的 TCP 拥塞控制算法，其目的是尽量跑满带宽，可以起到单边加速 TCP 连接的效果。BBR 是内嵌在 Linux 内核中的，而 Linux kernel 4.9 已加入了该算法。如果你的系统内核版本低于 4.9，则需要先升级 Linux 内核。<br>*# Ubuntu 18.04 及以上系统内核版本已高于 4.9，可直接开启 BBR*</p><ol><li>开启 BBR</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"net.core.default_qdisc=fq"</span> <span class="token operator">>></span> /etc/sysctl.conf<span class="token builtin class-name">echo</span> <span class="token string">"net.ipv4.tcp_congestion_control=bbr"</span> <span class="token operator">>></span> /etc/sysctl.conf</code></pre><p>然后，执行 <code>sysctl -p</code> 保存生效。</p><ol start="2"><li>查看 BBR 是否成功开启</li></ol><p>执行 <code>sysctl net.ipv4.tcp_available_congestion_control</code>， 结果中应有 <code>bbr</code>。<br>执行 <code>lsmod | grep bbr</code>，结果中应有 <code>tcp_bbr</code>。</p><p><strong>自动升级内核</strong></p><p>默认情况下，Ubuntu LTS 将保持在最初发布的 Linux 内核上。而 Ubuntu 硬件支持栈（<strong>H</strong>ard<strong>w</strong>are <strong>E</strong>nablement Stacks, HWE）可以为现有的 Ubuntu LTS 提供更新的内核支持，实现内核自动升级，方便我们体验较新内核的特性[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref10">10]</a>。</p><ol><li>查看当前系统内核版本</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> -r</code></pre><ol start="2"><li>安装 HWE</li></ol><p>使用包管理器即可安装 HWE：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> --install-recommends linux-generic-hwe-20.04  <span class="token comment"># For Ubuntu 20.04 LTS</span><span class="token function">apt</span> <span class="token function">install</span> --install-recommends linux-generic-hwe-18.04  <span class="token comment"># For Ubuntu 18.04 LTS</span></code></pre><ol start="3"><li>重启系统以应用新内核</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">reboot</span></code></pre><ol start="4"><li>删除旧内核（可选）[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref11">11]</a></li></ol><p>使用包管理器自动卸载即可：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> autoremove --purge</code></pre><p>如果只想保留当前最新的内核，可以使用以下命令<strong>（有风险，慎用）</strong>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token variable"><span class="token variable">$(</span>dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">"linux-(image|headers|modules)"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v hwe <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token punctuation">$(</span>uname -r <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">'-'</span> -f1,2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print <span class="token variable">$2</span>&#125;'</span><span class="token variable">)</span></span></code></pre><p>或者也可以手动卸载：</p><p><strong>卸载旧版 linux-image：</strong></p><p>获取 linux-image 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-image</code></pre><p>卸载旧版 linux-image：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-image名<span class="token operator">></span></code></pre><p><strong>卸载旧版 linux-headers：</strong></p><p>获取 linux-headers 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-headers</code></pre><p>卸载旧版 linux-headers：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-headers名<span class="token operator">></span></code></pre><p><strong>卸载旧版 linux-modules：</strong></p><p>获取 linux-modules 列表：</p><pre class="language-bash" data-language="bash"><code class="language-bash">dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> linux-modules</code></pre><p>卸载旧版 linux-modules：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge <span class="token operator">&lt;</span>旧linux-modules名<span class="token operator">></span></code></pre><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p><strong>安装 Docker-CE</strong></p><p><a href="https://www.docker.com/">Docker</a> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。iOS 上的 <a href="https://www.hyperapp.fun/zh/">HyperApp</a> 也正是借助 Docker 实现了自动部署应用。</p><p>安装 Docker 最方便的方式是使用官方脚本[<a href="https://blog.hly0928.com/post/vps-simple-setup/#ref12">12]</a>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO- get.docker.com <span class="token operator">|</span> <span class="token function">bash</span></code></pre><p>对于国内 VPS，还可以指定使用阿里云镜像进行安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> -qO- get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> -s docker --mirror Aliyun</code></pre><p><strong>以普通用户管理 Docker</strong></p><p>由于 Docker 守护进程绑定在 Unix socket 上，而 Unix socket 默认仅属于 <code>root</code> 用户，因此在通过普通用户管理 Docker 时，我们需要在命令前加上 <code>sudo</code>。为了方便使用，我们可以将普通用户添加到 <code>docker</code> 用户组中，这样就能直接使用 <code>docker</code> 命令而不需要 <code>sudo</code>。</p><ol><li>创建 <code>docker</code> 用户组</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">groupadd</span> docker<span class="token comment"># 较新的 Docker 安装中可能已经添加了 docker 用户组</span></code></pre><ol start="2"><li>将当前用户加入 <code>docker</code> 组</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gpasswd -a <span class="token environment constant">$USER</span> docker</code></pre><ol start="3"><li>登出并重新登入当前用户</li></ol><p>或者，你也可以使用 <code>newgrp</code> 命令以 <code>docker</code> 组重新登入系统：</p><pre class="language-bash" data-language="bash"><code class="language-bash">newgrp docker</code></pre><p>此时就可以直接使用 <code>docker</code> 命令管理容器了。</p><p><strong>限制 Docker 容器日志大小</strong></p><p>Docker 容器运行过程中会产生大量日志文件，如果不加限制可能会导致 VPS 磁盘空间不足。通过编辑 Docker 配置文件，我们可以限制容器日志大小。</p><p>编辑 <code>/etc/docker/daemon.json</code> 文件：<code>vim /etc/docker/daemon.json</code></p><p>添加 <code>log-dirver</code>和 <code>log-opts</code> 参数：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">"json-file"</span><span class="token punctuation">,</span>  <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"50m"</span><span class="token punctuation">,</span> <span class="token property">"max-file"</span><span class="token operator">:</span> <span class="token string">"3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>#样例中一个容器的日志大小上限是 50 M，最多创建 3 个日志文件</p><p>对于国内 VPS，还可以在配置文件中配置国内镜像源：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">"json-file"</span><span class="token punctuation">,</span>  <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"50m"</span><span class="token punctuation">,</span> <span class="token property">"max-file"</span><span class="token operator">:</span> <span class="token string">"3"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://&lt;阿里云ID>.mirror.aliyuncs.com"</span><span class="token punctuation">,</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>#阿里云源地址可以在 <a href="https://cr.console.aliyun.com/">容器镜像服务</a> &gt; 镜像加速器 下查看</p><p>保存退出，随后加载配置文件并重启 Docker：</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reloadsystemctl restart docker</code></pre><p>#设置的日志大小，只对新建的容器有效</p><p><strong>手动清理 Docker 容器日志</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">docker <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;if (NR>1)&#123;print <span class="token variable">$1</span>&#125;&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> docker inspect --format<span class="token operator">=</span><span class="token string">'&#123;&#123;.LogPath&#125;&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> truncate -s <span class="token number">0</span></code></pre><p><strong>解决 UFW 对 Docker 容器无效的问题</strong></p><p>在使用 Docker 暴露容器端口时，Docker 会直接操作 iptables NAT 规则，导致 ufw 无法管理 Docker 所发布的端口，这是一个严重的安全问题。好在通过编辑 ufw 的 <code>after.rules</code>，我们能够解决这一问题。</p><p>编辑 ufw 的 <code>after.rules</code>：<code>vim /etc/ufw/after.rules</code></p><p>在末尾写入如下内容：</p><pre class="language-Plain" data-language="Plain"><code class="language-Plain"># BEGIN UFW AND DOCKER*filter:ufw-user-forward - [0:0]:DOCKER-USER - [0:0]-A DOCKER-USER -j RETURN -s 10.0.0.0&#x2F;8-A DOCKER-USER -j RETURN -s 172.16.0.0&#x2F;12-A DOCKER-USER -j RETURN -s 192.168.0.0&#x2F;16-A DOCKER-USER -j ufw-user-forward-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0&#x2F;16-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0&#x2F;8-A DOCKER-USER -j DROP -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0&#x2F;12-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 192.168.0.0&#x2F;16-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 10.0.0.0&#x2F;8-A DOCKER-USER -j DROP -p udp -m udp --dport 0:32767 -d 172.16.0.0&#x2F;12-A DOCKER-USER -j RETURNCOMMIT# END UFW AND DOCKER</code></pre><p>保存退出，随后重启 ufw：</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl restart ufw</code></pre><p><em># 如果重启 ufw 之后规则没有生效，则需要重启服务器。</em></p><p>如果你要允许外部网络访问所有 Docker 发布的、内部端口为 <code>80</code> 的服务，则执行：</p><pre class="language-bash" data-language="bash"><code class="language-bash">ufw route allow from any to any port <span class="token number">80</span>ufw route allow proto tcp from any to any port <span class="token number">80</span>  <span class="token comment"># 仅允许 TCP 协议</span></code></pre><p><em># 此处的 <code>80</code> 是容器内部端口，而非使用 <code>-p 8080:80</code> 选项发布在服务器上的 <code>8080</code> 端口。</em></p><p><strong>安装curl</strong><br>ubuntu/debian 系统安装 Curl 方法: <code>apt-get update -y &amp;&amp; apt-get install curl -y</code><br>centos 系统安装 Curl 方法: <code>yum update -y &amp;&amp; yum install curl -y</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
